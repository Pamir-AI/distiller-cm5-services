<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Connecting to Network</title>
    <link rel="icon" href="{{ url_for('static', filename='images/pamir-logo-01.svg') }}">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <style>
        @font-face {
            font-family: 'MartianMono';
            src: url('{{ url_for("static", filename="fonts/MartianMonoNerdFont-CondensedBold.ttf") }}') format('truetype');
            font-weight: bold;
            font-style: normal;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'MartianMono', 'Courier New', 'Monaco', 'Menlo', monospace;
            background: #ffffff;
            color: #000000;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            line-height: 1.4;
        }
        
        .container {
            max-width: 520px;
            margin: 0 auto;
            background: #ffffff;
            border: 3px solid #000000;
            border-radius: 0;
            overflow: hidden;
        }
        
        .header {
            background: #000000;
            color: #ffffff;
            padding: 25px;
            text-align: center;
            border-bottom: 3px solid #000000;
        }
        
        .header h1 {
            margin: 0;
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .content {
            padding: 30px 25px;
            text-align: center;
        }
        
        .status-icon {
            font-size: 52px;
            margin-bottom: 25px;
            font-family: 'MartianMono', monospace;
            color: #000000;
            line-height: 1;
        }
        
        .status-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #000000;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .status-message {
            font-size: 14px;
            color: #000000;
            margin-bottom: 25px;
            line-height: 1.6;
        }
        
        .connecting-animation {
            font-size: 18px;
            font-weight: bold;
            color: #000000;
            margin: 25px 0;
            font-family: 'MartianMono', monospace;
        }
        
        .dots {
            animation: dots 1.5s infinite;
        }
        
        @keyframes dots {
            0%, 20% { content: ""; }
            40% { content: "."; }
            60% { content ".."; }
            80%, 100% { content: "..."; }
        }
        
        .dots::after {
            content: "";
            animation: dots-content 1.5s infinite;
        }
        
        @keyframes dots-content {
            0%, 20% { content: ""; }
            40% { content: "."; }
            60% { content: ".."; }
            80%, 100% { content: "..."; }
        }
        
        .connection-details {
            background: #f0f0f0;
            padding: 20px;
            border: 2px solid #000000;
            margin: 25px 0;
            text-align: left;
        }
        
        .detail-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px dashed #cccccc;
            font-size: 12px;
        }
        
        .detail-row:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        
        .detail-label {
            font-weight: bold;
            color: #000000;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .detail-value {
            color: #000000;
            text-align: right;
            font-family: 'MartianMono', monospace;
        }
        
        .footer {
            text-align: center;
            padding: 20px;
            color: #ffffff;
            font-size: 10px;
            border-top: 3px solid #000000;
            background: #000000;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
        }
        
        .footer::before {
            content: '';
            position: absolute;
            top: -3px;
            left: 0;
            right: 0;
            height: 3px;
            background: repeating-linear-gradient(
                90deg,
                #000000,
                #000000 8px,
                #ffffff 8px,
                #ffffff 16px
            );
        }
        
        .status-code {
            font-size: 16px;
            font-weight: bold;
            color: #000000;
            margin-bottom: 15px;
            font-family: 'MartianMono', monospace;
            letter-spacing: 1px;
        }
        
        .footer-content {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .footer-logo {
            height: 48px;
            width: auto;
            filter: brightness(0) invert(1);
        }
        
        .footer-text {
            font-size: 10px;
            letter-spacing: 0.3px;
        }
        
        /* Mobile responsiveness */
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
            
            .container {
                max-width: 100%;
                border-width: 2px;
            }
            
            .header {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 16px;
            }
            
            .content {
                padding: 20px 15px;
            }
            
            .status-icon {
                font-size: 40px;
            }
            
            .footer-content {
                flex-direction: column;
                gap: 8px;
            }
            
            .footer-logo {
                height: 40px;
            }
        }
    </style>

    <script>
        var connectionPhase = 'starting';
        var connectionStartTime = Date.now();
        var maxConnectionTime = 60000; // 60 seconds
        var statusCheckInterval;
        var lastSuccessfulCheck = Date.now();
        
        function updateConnectionStatus() {
            var elapsed = Date.now() - connectionStartTime;
            var elapsedSeconds = Math.floor(elapsed / 1000);
            
            // Update elapsed time display
            document.getElementById('elapsed-time').textContent = elapsedSeconds + 's';
            
            // Check for timeout
            if (elapsed > maxConnectionTime) {
                showError('Connection timeout. Please try again.');
                return;
            }
            
            // After 10 seconds, assume hotspot is down and start network discovery
            if (elapsed > 10000 && connectionPhase === 'starting') {
                connectionPhase = 'discovering';
                clearInterval(statusCheckInterval);
                discoverNewNetwork();
                return;
            }
            
            // Check connection status
            checkConnectionStatus();
        }
        
        function checkConnectionStatus() {
            var endpoints = [
                '/api/status',
                'http://{{ hotspot_ip }}:{{ web_port }}/api/status'
            ];
            
            tryStatusEndpoint(0, endpoints);
        }
        
        function tryStatusEndpoint(index, endpoints) {
            if (index >= endpoints.length) {
                console.log('All status endpoints failed, discovering new network');
                clearInterval(statusCheckInterval);
                discoverNewNetwork();
                return;
            }
            
            var endpoint = endpoints[index];
            
            fetch(endpoint, {
                method: 'GET',
                headers: {
                    'Cache-Control': 'no-cache'
                },
                timeout: 5000
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('HTTP ' + response.status);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    handleStatusResponse(data);
                    lastSuccessfulCheck = Date.now();
                } else {
                    setTimeout(() => tryStatusEndpoint(index + 1, endpoints), 1000);
                }
            })
            .catch(error => {
                setTimeout(() => tryStatusEndpoint(index + 1, endpoints), 500);
            });
        }
        
        function handleStatusResponse(data) {
            if (data.connected_to_target && data.current_state === 'connected' && data.redirect_url) {
                connectionPhase = 'connected';
                updateConnectionStatus('Connected');
                showSuccessWithRedirect(data.redirect_url, data.ip_address);
            } else if (data.connected_to_target && data.ip_address) {
                connectionPhase = 'connected';
                updateConnectionStatus('Connected');
                var redirectUrl = 'http://' + data.ip_address + ':{{ web_port }}';
                showSuccessWithRedirect(redirectUrl, data.ip_address);
            } else if (data.connected_to_hotspot && data.current_state === 'hotspot_mode') {
                updateConnectionStatus('Connection Failed');
                showError('Connection failed. Please check your password and try again.');
            } else if (data.current_state === 'connecting') {
                updateStatusMessage('Connecting to network...');
            }
        }
        
        function updateStatusMessage(message) {
            document.getElementById('status-message').textContent = message;
        }
        
        function updateConnectionStatus(status) {
            document.getElementById('connection-status').textContent = status;
        }
        
        function showSuccessWithRedirect(redirectUrl, ipAddress) {
            document.getElementById('status-code').textContent = '[CONNECTED]';
            document.getElementById('status-title').textContent = 'Connected!';
            document.getElementById('status-message').textContent = 'Successfully connected to network.';
            
            setTimeout(() => {
                window.location.href = redirectUrl;
            }, 3000);
        }
        
        function showError(message) {
            document.getElementById('status-code').textContent = '[ERROR]';
            document.getElementById('status-title').textContent = 'Connection Failed';
            document.getElementById('status-message').textContent = message;
            
            setTimeout(() => {
                window.location.href = '/';
            }, 5000);
        }
        
        function discoverNewNetwork() {
            console.log('Starting network discovery...');
            updateStatusMessage('Locating device on network...');
            
            var possiblePorts = [{{ web_port }}, 80, 8080];
            var currentHostname = window.location.hostname;
            
            console.log('Current hostname:', currentHostname);
            
            // If we're on the hotspot IP, try to discover the new network IP
            if (currentHostname.startsWith('192.168.4.') || currentHostname === '192.168.4.1') {
                // Try most common IP addresses across different network ranges
                // Start with 192.168.1.7 since that's what the device got in the logs
                var commonIPs = [
                    // Prioritize the IP we saw in the logs
                    '192.168.1.7',
                    // Other common 192.168.1.x addresses
                    '192.168.1.1', '192.168.1.2', '192.168.1.10', '192.168.1.100', 
                    '192.168.1.5', '192.168.1.3', '192.168.1.4', '192.168.1.6',
                    '192.168.1.8', '192.168.1.9', '192.168.1.11', '192.168.1.12',
                    // 192.168.0.x range  
                    '192.168.0.1', '192.168.0.2', '192.168.0.10', '192.168.0.100',
                    '192.168.0.7', '192.168.0.5', '192.168.0.3', '192.168.0.4',
                    // 10.0.0.x range
                    '10.0.0.1', '10.0.0.2', '10.0.0.10', '10.0.0.100',
                    '10.0.0.7', '10.0.0.5', '10.0.0.3', '10.0.0.4',
                    // 172.16.0.x range
                    '172.16.0.1', '172.16.0.2', '172.16.0.10', '172.16.0.100'
                ];
                
                tryDiscoverCommonIPs(commonIPs, possiblePorts, 0, 0);
            } else {
                // Try current hostname first
                tryDiscoverDevice(currentHostname, possiblePorts, 0);
            }
        }
        
        function tryDiscoverCommonIPs(ips, ports, ipIndex, portIndex) {
            if (ipIndex >= ips.length) {
                // All IPs exhausted for current port, try next port
                if (portIndex + 1 < ports.length) {
                    tryDiscoverCommonIPs(ips, ports, 0, portIndex + 1);
                } else {
                    // All combinations exhausted, fall back to home page
                    console.log('Network discovery failed, redirecting to home page');
                    setTimeout(() => {
                        window.location.href = '/';
                    }, 3000);
                }
                return;
            }
            
            var ip = ips[ipIndex];
            var port = ports[portIndex];
            var testUrl = 'http://' + ip + ':' + port + '/api/status';
            
            console.log('Trying to discover device at: ' + testUrl);
            
            // Create a promise that will timeout after 1 second for faster discovery
            var timeoutPromise = new Promise((resolve, reject) => {
                setTimeout(() => reject(new Error('timeout')), 1000);
            });
            
            Promise.race([
                fetch(testUrl, { method: 'GET' }),
                timeoutPromise
            ])
                .then(response => response.json())
                .then(data => {
                    console.log('Response from ' + ip + ':' + port, data);
                    if (data.success && data.connected_to_target) {
                        console.log('Found device at ' + ip + ':' + port + ', redirecting...');
                        showSuccessWithRedirect('http://' + ip + ':' + port, ip);
                    } else {
                        tryDiscoverCommonIPs(ips, ports, ipIndex + 1, portIndex);
                    }
                })
                .catch((error) => {
                    console.log('Failed to reach ' + ip + ':' + port + ' - ' + error.message);
                    tryDiscoverCommonIPs(ips, ports, ipIndex + 1, portIndex);
                });
        }
        
        function tryDiscoverDevice(hostname, ports, portIndex) {
            if (portIndex >= ports.length) {
                setTimeout(() => {
                    window.location.href = '/';
                }, 3000);
                return;
            }
            
            var port = ports[portIndex];
            var testUrl = 'http://' + hostname + ':' + port + '/api/status';
            
            fetch(testUrl, { method: 'GET', timeout: 3000 })
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.connected_to_target) {
                        showSuccessWithRedirect('http://' + hostname + ':' + port, hostname);
                    } else {
                        tryDiscoverDevice(hostname, ports, portIndex + 1);
                    }
                })
                .catch(() => {
                    tryDiscoverDevice(hostname, ports, portIndex + 1);
                });
        }
        
        // Start the connection monitoring
        document.addEventListener('DOMContentLoaded', function() {
            statusCheckInterval = setInterval(updateConnectionStatus, 2000);
            updateConnectionStatus();
        });
    </script>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>Connecting to Network</h1>
        </div>
        
        <div class="content">
            <div class="status-code" id="status-code">[CONNECTING]</div>
            
            <div class="status-title" id="status-title">Connecting</div>
            
            <div class="connecting-animation">
                <span class="dots"></span>
            </div>
            
            <div class="status-message" id="status-message">
                Connecting to "{{ ssid }}"...
            </div>
            
            <div class="connection-details">
                <div class="detail-row">
                    <span class="detail-label">Network</span>
                    <span class="detail-value">{{ ssid }}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Status</span>
                    <span class="detail-value" id="connection-status">Connecting</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Time</span>
                    <span class="detail-value" id="elapsed-time">0s</span>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <div class="footer-content">
                <img src="{{ url_for('static', filename='images/pamir-logo-01.svg') }}" alt="Pamir AI" class="footer-logo">
                <span class="footer-text">{{ device_name }} Network Setup</span>
            </div>
        </div>
    </div>
</body>
</html> 