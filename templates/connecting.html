<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Connecting to Network</title>
    <link rel="icon" href="{{ url_for('static', filename='images/pamir-logo-01.svg') }}">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- Allow insecure HTTP requests for local IoT device operation -->
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: http: https:;
        connect-src 'self' http: https: ws: wss:;
        img-src 'self' data: blob: http: https:;
        font-src 'self' data: http: https:;
        frame-src 'none';
        object-src 'none'
    ">
    
    <style>
        @font-face {
            font-family: 'MartianMono';
            src: url('{{ url_for("static", filename="fonts/MartianMonoNerdFont-CondensedBold.ttf") }}') format('truetype');
            font-weight: bold;
            font-style: normal;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'MartianMono', 'Courier New', 'Monaco', 'Menlo', monospace;
            background: #ffffff;
            color: #000000;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            line-height: 1.4;
        }
        
        .container {
            max-width: 520px;
            margin: 0 auto;
            background: #ffffff;
            border: 3px solid #000000;
            border-radius: 0;
            overflow: hidden;
        }
        
        .header {
            background: #000000;
            color: #ffffff;
            padding: 25px;
            text-align: center;
            border-bottom: 3px solid #000000;
        }
        
        .header h1 {
            margin: 0;
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .content {
            padding: 30px 25px;
            text-align: center;
        }
        
        .status-icon {
            font-size: 52px;
            margin-bottom: 25px;
            font-family: 'MartianMono', monospace;
            color: #000000;
            line-height: 1;
        }
        
        .status-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #000000;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .status-message {
            font-size: 14px;
            color: #000000;
            margin-bottom: 25px;
            line-height: 1.6;
        }
        
        .connecting-animation {
            font-size: 18px;
            font-weight: bold;
            color: #000000;
            margin: 25px 0;
            font-family: 'MartianMono', monospace;
        }
        
        .dots {
            animation: dots 1.5s infinite;
        }
        
        @keyframes dots {
            0%, 20% { content: ""; }
            40% { content: "."; }
            60% { content ".."; }
            80%, 100% { content: "..."; }
        }
        
        .dots::after {
            content: "";
            animation: dots-content 1.5s infinite;
        }
        
        @keyframes dots-content {
            0%, 20% { content: ""; }
            40% { content: "."; }
            60% { content: ".."; }
            80%, 100% { content: "..."; }
        }
        
        .connection-details {
            background: #f0f0f0;
            padding: 20px;
            border: 2px solid #000000;
            margin: 25px 0;
            text-align: left;
        }
        
        .detail-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px dashed #cccccc;
            font-size: 12px;
        }
        
        .detail-row:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        
        .detail-label {
            font-weight: bold;
            color: #000000;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .detail-value {
            color: #000000;
            text-align: right;
            font-family: 'MartianMono', monospace;
        }
        
        .footer {
            text-align: center;
            padding: 20px;
            color: #ffffff;
            font-size: 10px;
            border-top: 3px solid #000000;
            background: #000000;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
        }
        
        .footer::before {
            content: '';
            position: absolute;
            top: -3px;
            left: 0;
            right: 0;
            height: 3px;
            background: repeating-linear-gradient(
                90deg,
                #000000,
                #000000 8px,
                #ffffff 8px,
                #ffffff 16px
            );
        }
        
        .status-code {
            font-size: 16px;
            font-weight: bold;
            color: #000000;
            margin-bottom: 15px;
            font-family: 'MartianMono', monospace;
            letter-spacing: 1px;
        }
        
        .footer-content {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .footer-logo {
            height: 48px;
            width: auto;
            filter: brightness(0) invert(1);
        }
        
        .footer-text {
            font-size: 10px;
            letter-spacing: 0.3px;
        }
        
        /* Mobile responsiveness */
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
            
            .container {
                max-width: 100%;
                border-width: 2px;
            }
            
            .header {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 16px;
            }
            
            .content {
                padding: 20px 15px;
            }
            
            .status-icon {
                font-size: 40px;
            }
            
            .footer-content {
                flex-direction: column;
                gap: 8px;
            }
            
            .footer-logo {
                height: 40px;
            }
        }
    </style>

    <script>
        var connectionPhase = 'starting';
        var connectionStartTime = Date.now();
        var maxConnectionTime = 60000; // 60 seconds
        var statusCheckInterval;
        var lastSuccessfulCheck = Date.now();
        
        function updateConnectionStatus() {
            var elapsed = Date.now() - connectionStartTime;
            var elapsedSeconds = Math.floor(elapsed / 1000);
            
            // Update elapsed time display
            document.getElementById('elapsed-time').textContent = elapsedSeconds + 's';
            
            // Check for timeout
            if (elapsed > maxConnectionTime) {
                showError('Connection timeout. Please try again.');
                return;
            }
            
            // Trigger network discovery much more aggressively
            var timeSinceLastCheck = Date.now() - lastSuccessfulCheck;
            if ((elapsed > 6000 || timeSinceLastCheck > 5000) && connectionPhase === 'starting') {
                console.log('Triggering network discovery due to timeout or no status updates');
                console.log('Elapsed:', elapsed, 'ms, Time since last check:', timeSinceLastCheck, 'ms');
                connectionPhase = 'discovering';
                clearInterval(statusCheckInterval);
                discoverNewNetwork();
                return;
            }
            
            // Check connection status
            checkConnectionStatus();
        }
        
        function checkConnectionStatus() {
            var endpoints = [
                '/api/status',
                'http://{{ hotspot_ip }}:{{ web_port }}/api/status'
            ];
            
            tryStatusEndpoint(0, endpoints);
        }
        
        function tryStatusEndpoint(index, endpoints) {
            if (index >= endpoints.length) {
                console.log('All status endpoints failed, discovering new network');
                clearInterval(statusCheckInterval);
                discoverNewNetwork();
                return;
            }
            
            var endpoint = endpoints[index];
            
            fetch(endpoint, {
                method: 'GET',
                headers: {
                    'Cache-Control': 'no-cache',
                    'Pragma': 'no-cache'
                },
                timeout: 5000,
                // Explicitly allow insecure requests for local IoT device
                credentials: 'same-origin',
                mode: 'cors'
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('HTTP ' + response.status);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    handleStatusResponse(data);
                    lastSuccessfulCheck = Date.now();
                } else {
                    setTimeout(() => tryStatusEndpoint(index + 1, endpoints), 1000);
                }
            })
            .catch(error => {
                console.log('Status check failed for endpoint', endpoint, ':', error.message);
                // If this was the last endpoint and we're in connecting phase for a while,
                // trigger network discovery
                if (index === endpoints.length - 1 && Date.now() - connectionStartTime > 5000) {
                    console.log('All endpoints failed after 5s, starting discovery immediately');
                    clearInterval(statusCheckInterval);
                    discoverNewNetwork();
                } else {
                    setTimeout(() => tryStatusEndpoint(index + 1, endpoints), 300);
                }
            });
        }
        
        function handleStatusResponse(data) {
            console.log('Status response received:', JSON.stringify(data, null, 2));
            
            // Store device information for mDNS discovery
            if (data.device_id) {
                try {
                    localStorage.setItem('distiller_device_id', data.device_id);
                } catch(e) {
                    console.log('Could not store device ID');
                }
            }
            
            // SIMPLIFIED LOGIC: If connected to target network, IMMEDIATELY redirect
            if (data.connected_to_target === true) {
                connectionPhase = 'connected';
                updateConnectionStatus('Connected');
                
                console.log('Connected to target network! Redirecting immediately...');
                
                // Build redirect URL (prefer redirect_url, fallback to IP, then mDNS)
                var redirectUrl;
                if (data.redirect_url) {
                    redirectUrl = data.redirect_url + '/status';
                } else if (data.ip_address) {
                    redirectUrl = 'http://' + data.ip_address + ':{{ web_port }}/status';
                } else if (data.mdns_url) {
                    redirectUrl = data.mdns_url + '/status';
                } else {
                    redirectUrl = '/status'; // fallback
                }
                
                console.log('Redirecting to:', redirectUrl);
                showSuccessWithRedirect(redirectUrl, data.ip_address || 'device');
                return;
            }
            
            // Check for other states
            if (data.connected_to_hotspot && data.current_state === 'hotspot_mode') {
                updateConnectionStatus('Connection Failed');
                showError('Connection failed. Please check your password and try again.');
            } else if (data.current_state === 'connecting') {
                updateStatusMessage('Connecting to network...');
            } else {
                updateStatusMessage('Checking connection status...');
            }
        }
        
        function updateStatusMessage(message) {
            document.getElementById('status-message').textContent = message;
        }
        
        function updateConnectionStatus(status) {
            document.getElementById('connection-status').textContent = status;
        }
        
        function showSuccessWithRedirect(redirectUrl, ipAddress) {
            console.log('Showing success and redirecting to:', redirectUrl);
            
            document.getElementById('status-code').textContent = '[CONNECTED]';
            document.getElementById('status-title').textContent = 'Connected!';
            document.getElementById('status-message').innerHTML = 
                'Successfully connected to network!<br>' +
                'Redirecting to device status page...<br>' +
                '<small>If redirect fails, go to: ' + redirectUrl + '</small>';
            
            // Clear any existing intervals
            if (statusCheckInterval) {
                clearInterval(statusCheckInterval);
            }
            
            // Redirect immediately (1 second delay for user to see success message)
            setTimeout(() => {
                console.log('Executing redirect to:', redirectUrl);
                window.location.href = redirectUrl;
            }, 1000);
        }
        
        function showError(message) {
            document.getElementById('status-code').textContent = '[ERROR]';
            document.getElementById('status-title').textContent = 'Connection Failed';
            document.getElementById('status-message').textContent = message;
            
            setTimeout(() => {
                window.location.href = '/';
            }, 5000);
        }
        
        function discoverNewNetwork() {
            console.log('Starting network discovery...');
            updateStatusMessage('Locating device on network...');
            
            var possiblePorts = [{{ web_port }}, 80, 8080];
            var currentHostname = window.location.hostname;
            
            console.log('Current hostname:', currentHostname);
            
            // If we're on the hotspot IP, try to discover the new network
            if (currentHostname.startsWith('192.168.4.') || currentHostname === '192.168.4.1') {
                // First try mDNS-based discovery
                tryMdnsDiscovery(function(success) {
                    if (!success) {
                        console.log('mDNS discovery failed, falling back to IP scanning');
                        // Fallback to IP scanning if mDNS fails
                        tryIpRangeDiscovery();
                    }
                });
            } else {
                // Try current hostname first
                tryDiscoverDevice(currentHostname, possiblePorts, 0);
            }
        }
        
        function tryMdnsDiscovery(callback) {
            console.log('Attempting mDNS discovery...');
            updateStatusMessage('Looking for device via mDNS...');
            
            // Try to construct the likely mDNS name
            // Since we don't know the exact device ID from browser, we'll try common patterns
            var mdnsAttempts = [
                'distiller-setup.local',
                'distiller.local'
            ];
            
            // Also try to get device ID from previous interactions if available
            try {
                var storedDeviceId = localStorage.getItem('distiller_device_id');
                if (storedDeviceId) {
                    mdnsAttempts.unshift(storedDeviceId + '.local');
                }
            } catch(e) {
                console.log('No stored device ID');
            }
            
            var attempts = 0;
            var maxAttempts = mdnsAttempts.length;
            var foundDevice = false;
            
            function tryNextMdns() {
                if (attempts >= maxAttempts || foundDevice) {
                    callback(foundDevice);
                    return;
                }
                
                var mdnsName = mdnsAttempts[attempts];
                attempts++;
                
                console.log('Trying mDNS name:', mdnsName);
                
                var testUrl = 'http://' + mdnsName + ':{{ web_port }}';
                
                // Create a promise that will timeout after 3 seconds
                var timeoutPromise = new Promise((resolve, reject) => {
                    setTimeout(() => reject(new Error('timeout')), 3000);
                });
                
                Promise.race([
                    fetch(testUrl + '/api/status', { 
                        method: 'GET',
                        headers: {
                            'Cache-Control': 'no-cache',
                            'Pragma': 'no-cache'
                        },
                        credentials: 'same-origin',
                        mode: 'cors'
                    }),
                    timeoutPromise
                ])
                    .then(response => {
                        if (!response.ok) throw new Error('HTTP ' + response.status);
                        return response.json();
                    })
                    .then(data => {
                        console.log('mDNS response from ' + mdnsName + ':', data);
                        if (data.success && data.connected_to_target) {
                            foundDevice = true;
                            console.log('SUCCESS! Found device via mDNS:', mdnsName);
                            
                            // Store device hostname for future use
                            try {
                                var deviceId = mdnsName.replace('.local', '');
                                localStorage.setItem('distiller_device_id', deviceId);
                            } catch(e) {
                                console.log('Could not store device ID');
                            }
                            
                            var redirectUrl = data.redirect_url || (testUrl + '/status');
                            showSuccessWithRedirect(redirectUrl, mdnsName);
                            callback(true);
                        } else {
                            setTimeout(tryNextMdns, 500);
                        }
                    })
                    .catch((error) => {
                        console.log('mDNS test failed for ' + mdnsName + ':', error.message);
                        setTimeout(tryNextMdns, 500);
                    });
            }
            
            tryNextMdns();
        }
        
        function tryIpRangeDiscovery() {
            // Fallback to IP scanning when mDNS fails
            console.log('Starting IP range discovery...');
            updateStatusMessage('Scanning network for device...');
            
            // Try common network ranges and IP patterns to find the device
            // Prioritize the most likely IPs first based on actual connection logs
            var testIPs = [
                // HIGHEST PRIORITY: IPs that have worked before
                '192.168.1.7', '192.168.226.137', 
                
                // COMMON ROUTER DEFAULT RANGES
                '192.168.1.100', '192.168.1.101', '192.168.1.102', '192.168.1.103', '192.168.1.105',
                '192.168.0.100', '192.168.0.101', '192.168.0.102', '192.168.0.103', 
                
                // MOBILE HOTSPOT RANGES  
                '192.168.43.100', '192.168.43.101', '192.168.43.1', '192.168.43.2',
                '192.168.226.100', '192.168.226.101', '192.168.226.102',
                
                // OTHER COMMON RANGES
                '192.168.2.100', '192.168.2.101', '10.0.0.100', '10.0.0.101', 
                '172.16.0.100', '172.16.0.101'
            ];
            
            var foundDevice = false;
            var attempts = 0;
            var maxAttempts = testIPs.length;
            
            testIPs.forEach(function(testIP, index) {
                setTimeout(function() {
                    if (foundDevice) return; // Skip if already found
                    
                    var testUrl = 'http://' + testIP + ':{{ web_port }}';
                    console.log('Testing IP:', testIP);
                    
                    fetch(testUrl + '/api/status', {
                        method: 'GET',
                        headers: {
                            'Cache-Control': 'no-cache',
                            'Pragma': 'no-cache'
                        },
                        credentials: 'same-origin',
                        mode: 'cors',
                        timeout: 3000
                    })
                    .then(response => {
                        console.log('Response from', testIP, '- Status:', response.status);
                        if (!response.ok) throw new Error('HTTP ' + response.status);
                        return response.json();
                    })
                    .then(data => {
                        console.log('API response from', testIP, ':', JSON.stringify(data, null, 2));
                        
                        if (data.success && data.connected_to_target && data.current_state === 'connected' && !foundDevice) {
                            foundDevice = true;
                            console.log('SUCCESS! Found device at:', testIP);
                            clearInterval(statusCheckInterval); // Stop any polling
                            
                            // Immediately redirect browser to the working device URL
                            var redirectUrl = data.redirect_url || (testUrl + '/status');
                            console.log('Redirecting browser to:', redirectUrl);
                            
                            showSuccessWithRedirect(redirectUrl, testIP);
                        }
                    })
                    .catch(error => {
                        console.log('Test failed for', testIP, ':', error.message);
                        attempts++;
                        if (attempts >= maxAttempts && !foundDevice) {
                            console.log('All discovery attempts failed, showing fallback');
                            setTimeout(showConnectionFallback, 2000);
                        }
                    });
                }, index * 50); // 50ms intervals between attempts (even faster scanning)
            });
        }
        
        function showConnectionFallback() {
            updateStatusMessage('Connection completed. Checking device availability...');
            document.getElementById('status-code').textContent = '[UNKNOWN]';
            document.getElementById('status-title').textContent = 'Connection Status Unknown';
            document.getElementById('status-message').innerHTML = 
                'The connection process completed, but the device location could not be verified.<br><br>' +
                'Try accessing the device by:<br>' +
                '• Checking your router\'s connected devices<br>' +
                '• Using network scanner apps<br>' +
                '• Looking for "distiller-*.local" in your network';
            
            setTimeout(() => {
                window.location.href = '/';
            }, 10000);
        }
        
        function tryDiscoverDevice(hostname, ports, portIndex) {
            if (portIndex >= ports.length) {
                setTimeout(() => {
                    window.location.href = '/';
                }, 3000);
                return;
            }
            
            var port = ports[portIndex];
            var testUrl = 'http://' + hostname + ':' + port + '/api/status';
            
            fetch(testUrl, { 
                method: 'GET',
                headers: {
                    'Cache-Control': 'no-cache',
                    'Pragma': 'no-cache'
                },
                credentials: 'same-origin',
                mode: 'cors',
                timeout: 3000 
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.connected_to_target) {
                        showSuccessWithRedirect('http://' + hostname + ':' + port, hostname);
                    } else {
                        tryDiscoverDevice(hostname, ports, portIndex + 1);
                    }
                })
                .catch(() => {
                    tryDiscoverDevice(hostname, ports, portIndex + 1);
                });
        }
        
        // Start the connection monitoring
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Starting connection monitoring for SSID: {{ ssid }}');
            console.log('Hotspot IP: {{ hotspot_ip }}, Web Port: {{ web_port }}');
            
            // Check status every 1 second (more responsive)
            statusCheckInterval = setInterval(updateConnectionStatus, 1000);
            
            // Start checking immediately
            updateConnectionStatus();
            
            // AGGRESSIVE BACKUP: Start network discovery much earlier
            setTimeout(function() {
                if (connectionPhase === 'starting') {
                    console.log('Emergency discovery trigger after 8 seconds');
                    clearInterval(statusCheckInterval);
                    discoverNewNetwork();
                }
            }, 8000);
            
            // FINAL BACKUP: If still stuck after 12 seconds, force discovery
            setTimeout(function() {
                if (connectionPhase !== 'connected') {
                    console.log('Final emergency discovery trigger after 12 seconds');
                    clearInterval(statusCheckInterval);
                    discoverNewNetwork();
                }
            }, 12000);
        });
    </script>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>Connecting to Network</h1>
        </div>
        
        <div class="content">
            <div class="status-code" id="status-code">[CONNECTING]</div>
            
            <div class="status-title" id="status-title">Connecting</div>
            
            <div class="connecting-animation">
                <span class="dots"></span>
            </div>
            
            <div class="status-message" id="status-message">
                Connecting to "{{ ssid }}"...
            </div>
            
            <div class="connection-details">
                <div class="detail-row">
                    <span class="detail-label">Network</span>
                    <span class="detail-value">{{ ssid }}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Status</span>
                    <span class="detail-value" id="connection-status">Connecting</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Time</span>
                    <span class="detail-value" id="elapsed-time">0s</span>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <div class="footer-content">
                <img src="{{ url_for('static', filename='images/pamir-logo-01.svg') }}" alt="Pamir AI" class="footer-logo">
                <span class="footer-text">{{ device_name }} Network Setup</span>
            </div>
        </div>
    </div>
</body>
</html> 